# 21/10/2023

Hmmm masih bingung gimana cara optimasinya, kalo misal semua kombinasi pertemuan praktikum di pertimbangin, bakal butuh komputasi yang besar banget. Kemaren baru 1 kromosom aja butuh waktu lama buat swappingnya. Tapi ya, sebagian besar sistem penjadwalan fokus ke jadwal mingguan sih. Tapi bakal ribet ketika jumlah chapter nya ngga seimbang. Bisa sih sampe tahap akhir fokus ke generate jadwal mingguan, nanti ketika udah dapet jadwal mingguan itu di copy untuk minggu2 selanjutnya.

Tapi bakal ribet ngga sih ngedeteksi jadwalnya ada di minggu keberapa dll?

Hmm, berarti untuk slot time slot, bukan make format date dulu, tapi hari dulu?
Terus untuk mastiin semua chapter kebagian di jadwal, total chapter dibagi banyaknya minggu dulu? Chapter dibulatkan ke atas buat jaga2 kalo chapter ganjil.

Soalnya kayaknya struktur si tabu search udah dapet nih, tapi kendala di neighboring yang makan waktu banyak banget. Jadi antara rombak proses generasi chromosome, atau cari algoritma neighboring yang lebih efisien.

Pro di metode pertama sih jadwal jadi lebih konsisten tiap minggunya, tapi ya jadi monoton, itu juga ngga bisa menghandel kalo semisal si asisten ngga bisa hadir di tanggal tertentu.

Kalo modif jadi mingguan ... rada pusing juga ya . . .
Eh ngga juga deng, pas ngecek apakah ada jadwal yang bentrok cuman ngecek hari dan shift doang. 

Cukup ngubah kode bagian ini aja ngga sih? Jadi ngga perlu generate setiap kombinasi dari grup dan chapter, cukup cari aja selama jangka waktu praktikum, kira2 bisa berapa pertemuan gitu tiap minggunya.

``` Python
def generate_chromosome(self):
        # if settings.DEBUG:
        #     logger.info("Generating chromosome...")
        genes = []
        for group in self.group_data.groups:
            for module in self.module_data.modules:
                if group.module.id == module.id:
                    for chapter in module.chapters.all():
                        laboratory_id = module.laboratory.id
                        module_id = module.id
                        module_chapter_id = chapter.id
                        group_id = group.id
                        assistant_id = np.random.choice(self.assistant_by_lab[laboratory_id])
                        time_slot = self.create_time_slot(module_id)
                        gene = Gene(laboratory_id, module_id, module_chapter_id, group_id, assistant_id, time_slot)
                        genes.append(gene)
        chromosome = Chromosome(genes)
        return chromosome
```

Kalo di persempit lagi, bisa kayaknya nya fokus ke sini:
``` Python
                    for chapter in self.module.chapters.all():
                        laboratory_id = module.laboratory.id
                        module_id = module.id
                        module_chapter_id = chapter.id
                        group_id = group.id
                        assistant_id = np.random.choice(self.assistant_by_lab[laboratory_id])
                        time_slot = self.create_time_slot(module_id)
                        gene = Gene(laboratory_id, module_id, module_chapter_id, group_id, assistant_id, time_slot)
                        genes.append(gene)
```

Pertama kita bagi dulu jadi bentuk mingguan. Berati mesti ngitung dulu ya ada berapa minggu si praktikum dijalanin?
Berarti sebelum itu ditambahin ini dulu:
``` Python
        start = module_data.get_module(module_id).start_date
        end = module_data.get_module(module_id).end_date
        duration = (end - start).days + 1
        weeks_duration = ceil(duration / 7)
```

Itu udah dapet minggunya, terus dibagi deh biar ketauan kira2 dapet berapa pertemuan per minggunya;
``` Python
		chapter_total = module.chapters.count()
		weekly_chapter = ceil(chapter_total / weeks_duration)
```

Setelahya dijalanin deh perulangan sebanyak chapter permingguan, atau bisa dibilang pertemuan mengguan deh.
Apakah mungkin? Mari kita coba.

Kalo gitu berarti generate id chapternya sementara randomg dulu kali ya?