# 24/12/2023

Kemaren2 udah ada progress sih, tapi gw taro disini aja biar ngga ribet mikirinnya.
Hmmm, intinya gw nyoba2 nambah prosess pararel sih, awalnya rada ribet, mungkin karena gw ngga ngerti strukturnya. Tapi setelah coba2 akhirnya bisa, walau mayoritas dapet bantuan dari AI sih. Ini catetan yang gw tulis didalem jupyter ->

#### Pararel and Serial version comparison

Setelah dicoba, pada awalnya versi pararel lebih lambat dari versi serial, khususnya pada ukuran populasi rendah. Sekiranya antara 1 hingga 100 populasi, versi serial lebih cepat dari pada yang pararel. Tapi ketika ukuran populasi meningkat, setidaknya diatas 100, kecepatan versi pararel mulai mengungguli versi serial. Perbedaan yang dihasilkan juga cukup signifikan, pada saat populasi mencapai 512, versi pararel 1.5 kali lebih cepat dari versi serial. Apakah itu cukup signifikan? Mungkin kita coba lagi dengan ukuran populasi yang lebih besar, misal 1024 atau 2048. Sementara itu, ini adalah hasil perbandingan dari ujicoba sebelumnya. Untuk keterangan, ukuran chromosome untuk tiap populasi adalah 288.

| Population Size | Serial | Pararel | Pararel Speedup |
| --------------- | ------ | ------- | --------------- |
| 2               | 0.765  | 0.576   | 1.328           |
| 4               | 1.792  | 1.954   | 0.917           |
| 8               | 3.573  | 4.294   | 0.832           |
| 16              | 6.771  | 8.302   | 0.815           |
| 32              | 13.199 | 17.507  | 0.753           |
| 64              | 28.468 | 34.396  | 0.827           |
| 128             | 53.476 | 46.242  | 1.156           |
| 256             | 91.285 | 83.171  | 1.097           |
| 512             | 466.15 | 294.25  | 1.584           |
| 1024            | 385.61 | 304.31  | 1.267           |
| 2048            | 758.55 | 587.89  | 1.290           |

Kayaknya nanti bisa dipertimbangin deh mau make jenis proses yang mana, tergantung jumlah populasinya. Hmm kira2 bisa ngga ini diterapin di fungsi fitness. Di versi kode sebelumnya sebenernya lebih lama di ngurusin perhitungan fitness-nya, kalo generate population mah cuman diawal doang.

Selanjutnya kita fokus ke step selanjutnya .. . 

Eh selanjutnya fitness function, dan gw udah ada fitness function manager yang ngurus berbagai fitness function di dalem satu kelas, dan kayaknya ini lebih fleksibel. Kalo yang dulu kan semua fungsi fitness langsung dimasukin kedalam satu kelas, jadi bakal susah dimodifikasi. Hmm, keknya ribet kalo dibayangin penjelasan gw, ini kodenya:

```python
class FitnessFunction:
    def __init__(self, all: bool = True):
        self.minimize_conflicts = None
        self.maximize_resource_utilization = None
        self.participant_availability = None
        self.all = all

        # MaximizeResourceUtilization Parameters
        self.max_groups_per_assistant = 2
        self.max_shift_per_assistant = 16

    def initialize(self):
        self.minimize_conflicts = MinimizeConflicts()
        self.maximize_resource_utilization = MaximizeResourceUtilization(self.max_groups_per_assistant, self.max_shift_per_assistant)
        self.participant_availability = ParticipantAvailability(GroupData())
    
    def calculate_all_fitness(self, chromosome: Chromosome):
        fitness = []
        fitness.append(self.minimize_conflicts.calculate_fitness(chromosome))
        fitness.append(self.maximize_resource_utilization.calculate_fitness(chromosome))
        fitness.append(self.participant_availability.calculate_fitness(chromosome))
        return sum(fitness)

    
    def calculate_fitness(self, chromosome: Chromosome):
        if settings.DEBUG:
            logger.info(f"Calculating fitness for chromosome {chromosome}")
        fitness = self.calculate_all_fitness(chromosome)
        return fitness
```

Kalo dari sini, tiap settingan fungsi fitness diatur via kelas ini, jadi kalo ada kelas fitness baru bakal ribet, dan bakal overwhelmed si kodinger-nya. Satu kelass ada banyak properti yang mesti diatur, bakal pusing kan? Nah ini kode barunya:

```python
#Fitness Manager
class FitnessManager:
    def __init__(self, fitness_functions: List[BaseFitness]):
        self.fitness_functions = fitness_functions
    
    def __str__(self):
        return f"FitnessManager(fitness_functions={self.fitness_functions})"
    
    def __repr__(self):
        return self.__str__()
    
    def __call__(self, chromosome: Chromosome):
        return sum([fitness_function(chromosome) for fitness_function in self.fitness_functions])
    
    def configure(self, fitness_functions: List[BaseFitness]):
        self.fitness_functions = fitness_functions

    def grouped_fitness(self, chromosome: Chromosome):
        """Return a dictionary of fitness functions and their respective fitness value"""
        return {fitness_function.name: fitness_function(chromosome) for fitness_function in self.fitness_functions}
```

Jadi lebih simpel, tugas kelas ini cuman ngumpulin fungsi2 fitness yang udah dibikin sebelumnya kedalam satu kelas, jadi setelah dikumpulin tinggal panggil kelas ini aja. Begini contoh penggunannya:

```python
group_assignment_conflict_fitness = GroupAssignmentConflictFitness()
assistant_distribution_fitness = AssistantDistributionFitness()

assistant_distribution_fitness.configure(15, 15, 1, 1)
group_assignment_conflict_fitness.configure(2, 1)

fitness_manager = FitnessManager([group_assignment_conflict_fitness, assistant_distribution_fitness])

fitness_manager(population[0])
```

Lebih simpel jadinya.

Tapi bisa juga sih cukup manggil population.calculate_fitness(), soalnya di bagian pembangunan populasi langsung otomatis dimasukin fungsi fitness kedalam tiap populasi, walau belum dinamis sih, masih hardcoded di kelas Factory(). Ini kodenya:

```python
class Factory:
    def __init__(self):
        self.laboratories = LaboratoryData.get_laboratories()
        self.modules = ModuleData.get_modules()
        self.chapters = ChapterData.get_chapters()
        self.groups = GroupData.get_groups()
        self.participants = ParticipantData.get_participants()
        self.assistants = AssistantData.get_assistants()
        self.constant = Constant
        
        self.constraints = ConstraintManager([ChapterModuleConstraint(), GroupModuleConstraint(), ModuleLaboratoryConstraint(), AssistantLaboratoryConstraint(), ScheduleConstraint()])
        self.fitness_manager = FitnessManager([GroupAssignmentConflictFitness(), AssistantDistributionFitness()])
		
	#other code
	
	def generate_population(self, population_size: int) -> Population:
        """Generate a population based on the population size"""
        chromosomes = []
        for i in range(population_size):
            chromosomes.append(self.generate_chromosome())

        population = Population(chromosomes, self.fitness_manager)
        #population.calculate_fitness()
        return population
```

Hmmm berarti ngga perlu bikin lagi kan ya??? Berarti tinggal lanjut aja kan yaa? Mungkin nanti2, bakal bisa tambahin fitness function sendiri. Berarti bisa moveon ke operator.

Hmmm udah sampe fungsi mutation, sebenernya rada bingung sih, pas generate chromosome, apa mending masukin id aja, atau sekalian sama objeknya ya? Tapi performanya sejauh ini ngga jauh beda sih ama kalo masukin id doang, apa coba dulu? Paling cuman beda pas generate di awal aja, kalo masukin seluruh objek setidaknya jadi mempermudah buat cek and ricek segalanya. Ngga perlu pusing2 manggil data berbasiskan id lagi.

Wait, chat gpt memberikan solusi yang lebih baik, yaitu dengan menggunakan metode hybrid. Jadi yang di store di gene cukup id-nya aja, tapi ketika butuh data lengkapnya, bisa manggil property yang ada di dalam gene-nya. Awalnya gw cuman berasumsi di dalem gene cuman perlu id doang.

Senernya setelah diitung2, mau pake id doang atau sekalian objek, pas generate populasinya sama2 aja sih. Tapi mungkin bakal jadi beban memori kalo kebanyakan. Baiklah kita coba hybrid aja.

--------------------

Baiklah sudahhh, sekarang gene cuman diisi id doang, tapi ketika data lengkapnya dibutuhin, si gene bisa tinggal manggil aja. Dulu rada pusing dan ribet kalo semisal butuh data lab dari gene, tapi di gene cuman ada id nya doang, bakal ribet kalo mesti manggil kelasnya dulu.
Fungsi mutasi juga udah kelar, sekarang tinggal lanjut ke fungsi crossover mungking.

Keknya crossover juga udah.

------------------

hmmm fungsi generate_time_slot banyak dipake, keknya mending dibikin fungsi umum deh,
fungsi ini:
```python
def generate_time_slot(self, start_date, end_date):
        """Generate time slots based on the start date, end date, days and shifts"""
        #if start_date not start from Monday, then start from the next Monday
        if start_date.weekday() != 0:
            start_date = start_date + timedelta(days=7 - start_date.weekday())
        duration = (end_date - start_date).days + 1
        weeks_duration = floor(duration / 7)
        random_weeks = np.random.randint(0, weeks_duration)
        random_days = np.random.choice(Constant.days)
        random_shifts = np.random.choice(Constant.shifts)
        random_date = start_date + timedelta(days=random_weeks * 7 + Constant.days.index(random_days))
        return TimeSlot(random_date, random_days, random_shifts)
```

Tapi nanti aja deh, pas bagian rapihin.

hmmmmm, repair keknya udah? dan kok kayak lebih cepet ya.